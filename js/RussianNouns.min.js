/*!
  RussianNounsJS v1.1.0.SNAPSHOT

  Copyright (c) 2011-2020 Устинов Георгий Михайлович

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
!function(e, t) {
	"function" == typeof define && define.amd ? define([], t) : "object" == typeof module && module.exports ? module.exports = t() : e.RussianNouns = t();
}("undefined" != typeof self ? self : this, function() {
	"use strict";
	const e = Object.freeze({
		NOMINATIVE: "именительный",
		GENITIVE: "родительный",
		DATIVE: "дательный",
		ACCUSATIVE: "винительный",
		INSTRUMENTAL: "творительный",
		PREPOSITIONAL: "предложный",
		LOCATIVE: "местный"
	}), t = Object.freeze({
		FEMININE: "женский",
		MASCULINE: "мужской",
		NEUTER: "средний",
		COMMON: "общий"
	}), n = Object.freeze([ e.NOMINATIVE, e.GENITIVE, e.DATIVE, e.ACCUSATIVE, e.INSTRUMENTAL, e.PREPOSITIONAL, e.LOCATIVE ]), s = {
		Case: e,
		Gender: t,
		CASES: n,
		LemmaException: class extends Error {},
		StressDictionaryException: class extends Error {},
		Lemma: class {
			constructor(e) {
				function n(e) {
					if (null != e && "boolean" != typeof e) {
						throw new s.LemmaException("Must be boolean.");
					}
				}
				if (e instanceof s.Lemma) {
					this.pluraliaTantum = e.pluraliaTantum, this.indeclinable = e.indeclinable, this.animate = e.animate, 
					this.surname = e.surname, this.name = e.name, this.transport = e.transport, this.watercraft = e.watercraft, 
					this.internalText = e.internalText, this.lowerCaseText = e.lowerCaseText, this.internalGender = e.internalGender;
				} else {
					if (null == e) {
						throw new s.LemmaException("No parameters specified.");
					}
					if (n(e.pluraliaTantum), n(e.indeclinable), this.pluraliaTantum = !!e.pluraliaTantum, 
					this.indeclinable = !!e.indeclinable, n(e.animate), n(e.surname), n(e.name), n(e.transport), 
					n(e.watercraft), this.animate = !!e.animate, this.surname = !!e.surname, this.name = !!e.name, 
					this.transport = !!e.transport, this.watercraft = !!e.watercraft, null == e.text) {
						throw new s.LemmaException("A cyrillic word required.");
					}
					if (this.internalText = e.text, this.lowerCaseText = this.internalText.toLowerCase(), 
					!e.pluraliaTantum) {
						if (null == e.gender) {
							throw new s.LemmaException("A grammatical gender required.");
						}
						if (!Object.values(t).includes(e.gender)) {
							throw new s.LemmaException("Bad grammatical gender.");
						}
						this.internalGender = e.gender;
					}
				}
			}
			newText(e) {
				const t = new s.Lemma(this);
				return t.internalText = e(t), t.lowerCaseText = t.internalText.toLowerCase(), Object.freeze(t);
			}
			newGender(e) {
				const t = new s.Lemma(this);
				return t.internalGender = e(t), Object.freeze(t);
			}
			equals(e) {
				return e instanceof s.Lemma && this.lower() === e.lower() && this.isPluraliaTantum() === e.isPluraliaTantum() && (this.isPluraliaTantum() || this.getGender() === e.getGender()) && this.isIndeclinable() === e.isIndeclinable() && this.isAnimate() === e.isAnimate() && this.isASurname() === e.isASurname() && this.isAName() === e.isAName() && this.isATransport() === e.isATransport() && this.isAWatercraft() === e.isAWatercraft();
			}
			fuzzyEquals(e) {
				return e instanceof s.Lemma && A(this.lower()) === A(e.lower()) && this.isPluraliaTantum() === e.isPluraliaTantum() && (this.isPluraliaTantum() || this.getGender() === e.getGender()) && this.isIndeclinable() === e.isIndeclinable();
			}
			text() {
				return this.internalText;
			}
			lower() {
				return this.lowerCaseText;
			}
			isPluraliaTantum() {
				return this.pluraliaTantum;
			}
			getGender() {
				return this.internalGender;
			}
			isIndeclinable() {
				return this.indeclinable;
			}
			isAnimate() {
				return this.animate || this.surname || this.name;
			}
			isASurname() {
				return this.surname;
			}
			isAName() {
				return this.name;
			}
			isATransport() {
				return this.transport || this.watercraft;
			}
			isAWatercraft() {
				return this.watercraft;
			}
		},
		createLemma: e => e instanceof s.Lemma ? e : Object.freeze(new s.Lemma(e)),
		getDeclension: e => L(s.createLemma(e)),
		getSchoolDeclension: e => {
			const t = L(s.createLemma(e));
			return 1 === t ? 2 : 2 === t ? 1 : t;
		},
		FIXED_STEM_STRESS: "SSSSSSS-SSSSSS",
		FIXED_ENDING_STRESS: "EEEEEEE-EEEEEE",
		StressDictionary: class {
			constructor() {
				this.data = {};
			}
			put(e, t) {
				if (!t.match(/^[SsbeE]{7}-[SsbeE]{6}$/)) {
					throw new s.StressDictionaryException("Bad settings format.");
				}
				const n = s.createLemma(e), r = A(n.lower());
				let i = this.data[r];
				i instanceof Array || (i = [], this.data[r] = i);
				const a = i.find(e => n.equals(e[0]));
				a ? a[1] = t : i.push([ n, t ]);
			}
			get(e, t) {
				const n = s.createLemma(e), r = A(n.lower()), i = this.data[r];
				if (i instanceof Array) {
					let e = i.find(e => n.equals(e[0]));
					if (!e && t && (e = i.find(e => n.fuzzyEquals(e[0]))), e) {
						return e[1];
					}
				}
			}
			remove(e) {
				const t = s.createLemma(e), n = A(t.lower()), r = this.data[n];
				r instanceof Array && (this.data[n] = r.filter(e => !t.equals(e[0])), 0 === this.data[n].length && delete this.data[n]);
			}
			hasStressedEndingSingular(e, t) {
				const s = n.indexOf(t);
				if (s >= 0) {
					const t = this.get(e, !0);
					if (t) {
						const e = t.split("-")[0];
						return "E" === e[s] ? [ !0 ] : "e" === e[s] ? [ !0, !1 ] : "b" === e[s] ? [ !1, !0 ] : "s" === e[s] ? [ !1, !0 ] : [ !1 ];
					}
				}
				return [];
			}
			hasStressedEndingPlural(e, t) {
				const s = n.indexOf(t);
				if (s >= 0 && s < 6) {
					const t = this.get(e, !0);
					if (t) {
						const e = t.split("-")[1];
						return "E" === e[s] ? [ !0 ] : "e" === e[s] ? [ !0, !1 ] : "b" === e[s] ? [ !1, !0 ] : "s" === e[s] ? [ !1, !0 ] : [ !1 ];
					}
				}
				return [];
			}
			find(e) {
				const t = A(e).toLowerCase(), n = this.data[t];
				return n instanceof Array ? n.map(e => e[0]) : [];
			}
		},
		Engine: class {
			constructor() {
				this.sd = function() {
					const e = new s.StressDictionary();
					function n(t, n, s) {
						const r = s.split(",");
						for (let s of r) {
							const r = Object.assign({}, t);
							r.text = s, e.put(r, n);
						}
					}
					function r(n, s) {
						e.put({
							text: s,
							gender: t.MASCULINE
						}, n);
					}
					n({
						gender: t.MASCULINE
					}, s.FIXED_STEM_STRESS, "брёх,дёрн,идиш,имидж,мед"), n({
						gender: t.MASCULINE
					}, "SSSSSSS-EEEEEE", "адрес,век,вечер,город,детдом,поезд"), n({
						gender: t.MASCULINE
					}, "SSSSSSE-EEEEEE", "берег,бок,вес,лес,снег,дом,катер,счёт,мёд"), n({
						gender: t.MASCULINE,
						animate: !0
					}, s.FIXED_STEM_STRESS, "балансёр,шофёр"), n({
						gender: t.MASCULINE
					}, "SSSSSSS-bbbbbb", "вексель,ветер"), r("SSSSSSE-ESEEEE", "глаз"), r("SSSSSSE-bEEbEE", "год"), 
					r("SSSSSSb-bbbbbb", "цех"), r("SSSSSSE-EEEEEE", "счёт"), n({
						gender: t.NEUTER
					}, "EEEEEEE-SSSSSS", "тесло,стекло,автостекло,бронестекло,оргстекло,пеностекло,смарт-стекло,спецстекло,бедро,берцо,блесна,чело,стегно,стебло"), 
					n({
						gender: t.MASCULINE
					}, "SbbSbbb-bbbbbb", "грош,шприц"), n({
						gender: t.MASCULINE
					}, "SssSsss-ssssss", "кишмиш,кряж,слеш,слэш"), n({
						gender: t.MASCULINE,
						animate: !0
					}, "Sssssss-ssssss", "паныч"), r("SEESeEE-EEEEEE", "стеллаж"), r("SeeSeee-eeeeee", "шиномонтаж"), 
					n({
						gender: t.MASCULINE
					}, "SEESEEE-EEEEEE", "багаж,грузобагаж,товаробагаж,багрец,барыш,беляш,бердыш,бич,бандаж,блиндаж,бубенец,буж,валец,варенец,венец,вираж,витраж,волосенец,волчец,вольтаж,воронец,галдёж,гамма-луч,гнилец,гараж,автогараж,голец,головач,голыш,горбач,горлач,голубец,грабёж,гуж,гуляш,дворец,делёж,дергач,долбёж,долгунец,драч,ёрш,зубец,зубрёж,изразец,калач,ключ,камыш,карандаш,картёж,кедрач,кирпич,клинец,ковш,корец,козелец,конец,кострец,копач,крепёж,крестец,круглыш,кругляш,крыж,крылач,кулеш,кулич,кумач,контуш,кунтуш,купаж,кураж,кутёж,леденец,листаж,литраж,луч,метраж,меч,мираж,монтаж,муляж,мятеж,мокрец,москвич,неплатёж,нож,нутрец,овсец,огурец,орлец,острец,падеж,падёж,паж,палаш,паралич,первач,пернач,песец,пиздец,хуец,пихтач,платёж,погребец,подэтаж,поставец,поташ,правёж,путец,пыж,пугач,резец,ржанец,рубеж,рубец,рогач,свербёж,светец,сенаж,скулёж,слопец,сныч,солонец,сосец,свинец,тетраэтилсвинец,секач,спорыш,столбец,строгач,сургуч,сутаж,сыпец,сырец,сыровец,терпёж,типаж,тираж,толкач,торец,тягач,тяж,типец,тирлич,тупец,тупыш,целкач,чабрец,чепец,фураж,хвостец,хлопунец,холодец,чертёж,чистец,шалаш,шантаж,шиш,щипец,электронож,этаж,ясенец"), 
					n({
						gender: t.MASCULINE,
						animate: !0
					}, "SEEEEEE-EEEEEE", "алкаш,басмач,беглец,белец,бирюч,бич,близнец,бомж,богач,боец,борец,бородач,брюхач,вдовец,волосач,врач,главврач,ветврач,военврач,диетврач,санврач,глупец,глупыш,голец,головач,голыш,гонец,горбач,гордец,грач,гребец,делец,дергач,донец,дохлец,драч,ёж,ёрш,елец,живец,жилец,жнец,избач,ингуш,камыш,корж,морж,кольчец,копач,кормач,коротыш,косач,косец,космач,крепыш,кряж,кудряш,кузнец,купец,латыш,легаш,лжец,лихач,ловец,ловкач,лохмач,малец,малыш,мертвец,мигач,мордаш,мокрец,москвич,мудрец,мураш,носач,оголец,омич,отец,праотец,паж,камер-паж,палач,пантач,певец,песец,писец,плавунец,подлец,племяш,пловец,портач,продавец,перепродавец,пошлец,пришлец,простец,птенец,пузач,пугач,рвач,рифмач,рогач,рунец,рыбец,ремнец,самец,сарыч,севец,силач,синец,скворец,скопец,скрипач,скупец,секач,слепец,слепыш,слухач,смехач,сморкач,снохач,соистец,сорванец,спец,военспец,стервец,стрелец,стригунец,стриж,стукач,сыч,стрекач,струнец,творец,телец,ткач,толмач,торгаш,трубач,трюкач,тунец,трепач,трепец,тупец,тупыш,тяглец,удалец,уж,усач,хитрец,хохмач,храбрец,хромец,хрыч,хач,циркач,червец,чернец,черныш,швец,шельмец,чтец,чиж,юнец"), 
					e.put({
						text: "судья",
						gender: t.COMMON,
						animate: !0
					}, "EEEEEEE-SSSSSS");
					for (let n of [ "семья", "макросемья" ]) {
						e.put({
							text: n,
							gender: t.FEMININE
						}, "EEEEEEE-SESSSS");
					}
					return e.put({
						text: "свинья",
						gender: t.FEMININE,
						animate: !0
					}, "EEEEEEE-SESESS"), e.put({
						text: "скамья",
						gender: t.FEMININE
					}, "EEEEEEE-eEeeee"), e;
				}();
			}
			decline(n, r, a) {
				return function(n, s, a, u) {
					const E = function(n, s, r, a) {
						const u = s.text();
						if (s.isIndeclinable()) {
							return u;
						}
						if (s.isPluraliaTantum()) {
							return M(n, s, r, u);
						}
						if (a) {
							return M(n, s, r, a);
						}
						switch (L(s)) {
						  case -1:
							return u;

						  case 0:
							return O(n, s, r);

						  case 1:
							return function n(s, r, a) {
								const u = r.text(), E = r.lower(), d = r.getGender(), S = function(e) {
									if (e.startsWith("пол") && [ "и", "ы", "а", "я", "ь" ].includes(l(e)) && c(e) >= 2) {
										let t = e.substring(3), n = t.search(/[а-яА-Я]/);
										return n >= 0 && i.includes(t[n].toLowerCase());
									}
									return !1;
								}(E);
								if (S && f(E, [ "и", "ы" ])) {
									if ([ e.NOMINATIVE, e.ACCUSATIVE ].includes(a)) {
										return u;
									}
									{
										const t = e => [ "полминуты" ].includes(e.lower()) ? e.text() : "полу" + e.text().substring(3);
										if ("полпути" === E) {
											if ([ e.PREPOSITIONAL, e.LOCATIVE ].includes(a)) {
												return u;
											}
											{
												let e = r.newText(e => h(t(e)) + "ь");
												return O(s, e, a);
											}
										}
										if (E.endsWith("зни")) {
											let e = r.newText(e => h(t(e)) + "ь");
											return W(s, e, a);
										}
										{
											let e = r.newText(e => h(t(e)) + ("н" === l(e.lower()) ? "я" : "а"));
											return x(s, e, a);
										}
									}
								}
								let I = N(r), T = h(u);
								const p = S && E.endsWith("я") || b(E);
								S && (I = "полу" + I.substring(3), T = "полу" + T.substring(3));
								let m = I.toLowerCase();
								const L = (e, t) => {
									const n = s.sd.hasStressedEndingSingular(r, a);
									return n.length || n.push(!1), n.map(n => t(n ? A(e) : e, n));
								}, V = () => "й" === l(E) || [ "ий", "ие", "иё" ].includes(o(E, 2)), M = () => "чщ".includes(l(m)), U = () => "ый" === o(E, 2) || E.endsWith("ной") && c(u) >= 2;
								if (e.NOMINATIVE === a) {
									return u;
								}
								if (e.GENITIVE === a) {
									return V() && r.isASurname() || U() || f(E, [ "ое", "нький", "ский", "евой", "овой" ]) ? I + "ого" : E.endsWith("ее") ? I + "его" : V() ? T + "я" : p && !M() ? I + "я" : w(E) ? g(u, r) + "ца" : C(E) ? h(T) + "ка" : r.isASurname() || -1 === m.indexOf("ё") ? I + "а" : L(I, e => e + "а");
								}
								if (e.DATIVE === a) {
									return V() && r.isASurname() || U() || f(E, [ "ое", "нький", "ский", "евой", "овой" ]) ? I + "ому" : E.endsWith("ее") ? I + "ему" : V() ? T + "ю" : p && !M() ? I + "ю" : w(E) ? g(u, r) + "цу" : C(E) ? h(T) + "ку" : r.isASurname() || -1 === m.indexOf("ё") ? I + "у" : L(I, e => e + "у");
								}
								if (e.ACCUSATIVE === a) {
									if (d === t.NEUTER) {
										return u;
									}
									return !0 === r.isAnimate() ? n(s, r, e.GENITIVE) : u;
								}
								if (e.INSTRUMENTAL === a) {
									return V() && r.isASurname() || f(E, [ "ое", "ее", "нький", "ский" ]) ? "целое" !== E ? I + "им" : I + "ым" : U() || f(E, [ "евой", "овой" ]) ? I + "ым" : V() ? T + "ем" : p || "жчш".includes(l(m)) ? L(I, (e, t) => t ? e + "ом" : e + "ем") : w(E) ? L(u, (e, t) => t ? g(e, r) + "цом" : g(e, r) + "цем") : E.endsWith("це") ? u + "м" : C(E) ? h(T) + "ком" : (() => r.isASurname() && (E.endsWith("ын") || E.endsWith("ин") || E.endsWith("ов") || E.endsWith("ев") || E.endsWith("ёв")))() ? u + "ым" : r.isASurname() || -1 === m.indexOf("ё") ? I + "ом" : L(I, e => e + "ом");
								}
								if (e.PREPOSITIONAL === a) {
									return V() && r.isASurname() || U() || f(E, [ "ое", "нький", "ский", "евой", "овой" ]) ? I + "ом" : E.endsWith("ее") ? I + "ем" : f(E, [ "ий", "ие", "чье", "тье", "дье", "вье", "бье", "енье", "ружье", "божье", "верье", "мужье" ]) ? T + "и" : "й" === l(E) || "иё" === o(E, 2) ? T + "е" : w(E) ? g(u, r) + "це" : C(E) ? h(T) + "ке" : r.isASurname() || -1 === m.indexOf("ё") ? I + "е" : L(I, e => e + "е");
								}
								if (e.LOCATIVE === a) {
									const t = "ад,баз,бал,бег,берег,бережок,бой,бок,бочок,бор,борт,бред,быт,век,верх,вес,ветер,ветр,вид,воз,газ,глаз,год,горб,гроб,день,долг,дух,дым,жир,зад,клей,кол,кон,корень,край,круг,лад,лёд,лед,лоб,мох,угол,лес,луг,мёд,мел,мех,мозг,низ,нос,плен,пол,полк,артполк,порт,аэропорт,пух,рай,род,сад,снег,строй,счёт,счет,тыл,ход,шкаф,яр".split(","), i = "вор".split(",");
									return t.includes(E) && !r.isAnimate() || i.includes(E) ? "й" === l(E) ? A(T) + "ю" : p ? A(I) + "ю" : C(E) ? A(h(T)) + "ку" : A(I) + "у" : n(s, r, e.PREPOSITIONAL);
								}
							}(n, s, r);

						  case 2:
							return x(n, s, r);

						  case 3:
							return W(n, s, r);
						}
					}(n, s, r, u);
					return E instanceof Array ? E : [ E ];
				}(this, s.createLemma(n), 0, a);
			}
			pluralize(n) {
				const r = s.createLemma(n);
				return r.isPluraliaTantum() ? [ r.text() ] : function(n, s) {
					const r = [], i = s.text(), a = s.lower(), m = N(s), O = m.toLowerCase(), x = n.sd.hasStressedEndingPlural(s, e.NOMINATIVE);
					Object.freeze(x);
					const W = t => {
						const r = n.sd.hasStressedEndingPlural(s, e.NOMINATIVE).map(e => !e);
						return r.length ? r.map(e => e ? p(O) ? t(T(m)) : t(m) : t(A(m))) : [ t(m) ];
					}, M = (e, t) => {
						const n = x.slice();
						return n.length || n.push(!1), n.map(n => t(n ? A(e) : e));
					}, U = s.getGender(), P = L(s), R = ("й" == l(a) || u(l(i))) && u(l(h(i))) ? h(i) : m, G = () => (a.endsWith("евич") || a.endsWith("евна")) && a.indexOf("ье") >= 0;
					function y() {
						const e = R, t = e.toLowerCase().indexOf("ье"), n = E("и", e[t]);
						return e.substring(0, t) + n + e.substring(t + 1);
					}
					function D(e) {
						"гжкхчшщ".includes(l(O)) || "яйь".includes(l(a)) ? G() ? (r.push(y() + "и"), r.push(R + "и")) : r.push(R + "и") : w(a) ? r.push(g(i, s) + "цы") : G() ? (r.push(y() + "ы"), 
						r.push(R + "ы")) : e ? r.push(R + "ы") : Array.prototype.push.apply(r, M(R, e => e + "ы"));
					}
					const j = [ "зять", "князь", "друг", "брат", "собрат", "лист", "стул", "брус", "обод", "полоз", "струп", "подмастерье", "перо", "шило" ], z = "ь" === l(O) ? m : "к" === l(O) ? h(m) + "чь" : "г" === l(O) ? h(m) + "зь" : m + "ь";
					switch (P) {
					  case -1:
						r.push(i);
						break;

					  case 0:
						if ("путь" === a) {
							r.push("пути");
						} else {
							if (!a.endsWith("дитя")) {
								throw new Error("unsupported");
							}
							r.push(d(i, 3) + "ети");
						}
						break;

					  case 1:
						if (j.includes(a)) {
							r.push(z + "я");
						} else if (t.MASCULINE === U) {
							const e = [ "адрес", "берег", "бок", "век", "вес", "вечер", "лес", "снег", "глаз", "город", "дом", "детдом", "катер", "счет", "счёт" ], t = [ "поезд", "цех" ], n = [ "год", "вексель", "ветер" ], u = [ "лоскут", "повод", "прут", "сук" ];
							"сын" === a ? (r.push("сыновья"), D()) : "человек" === a ? (r.push("люди"), D()) : u.includes(a) ? (D(), 
							r.push(z + "я")) : e.includes(a) || f(a, t) || n.includes(a) ? (b(a) ? Array.prototype.push.apply(r, W(e => e + "я")) : x.includes(!0) ? r.push(A(m) + "а") : r.push(m + "а"), 
							n.includes(a) && D()) : (a.endsWith("анин") || a.endsWith("янин")) && !s.isAName() || [ "барин", "боярин" ].includes(a) ? (r.push(d(i, 2) + "е"), 
							"барин" === a && r.push(d(i, 2) + "ы")) : [ "цыган" ].includes(a) ? r.push(i + "е") : !a.endsWith("ёнок") && !a.endsWith("енок") || f(a, [ "коленок", "стенок", "венок", "ценок" ]) ? a.endsWith("ёночек") ? r.push(d(i, 6) + "ятки") : a.endsWith("онок") && "жчш".includes(S(a, 4)) && !a.endsWith("бочонок") ? r.push(d(i, 4) + "ата") : C(a) ? r.push(d(i, 2) + "ки") : a.endsWith("ый") || f(a, [ "щий", "чий", "жний", "шний", "ский" ]) ? r.push(h(i) + "е") : a.endsWith("вой") && c(d(i, 3)) >= 2 || f(a, [ "ной", "мой" ]) && i.length >= 6 ? r.push(d(i, 2) + "ые") : a.endsWith("хой") ? r.push(d(i, 2) + "ие") : a.endsWith("его") ? r.push(d(i, 3) + "ие") : D() : r.push(d(i, 4) + "ята");
						} else if (t.NEUTER === U) {
							if ("ухо" === a) {
								r.push("уши");
							} else if ("око" === a) {
								r.push("очи");
							} else if (f(a, [ "ко", "чо" ]) && !f(a, [ "войско", "облако" ])) {
								r.push(h(i) + "и");
							} else if (a.endsWith("имое")) {
								r.push(m + "ые");
							} else if (a.endsWith("ее")) {
								r.push(m + "ие");
							} else if (a.endsWith("ое")) {
								f(O, [ "г", "к", "ж", "ш" ]) ? r.push(m + "ие") : r.push(m + "ые");
							} else if (f(a, [ "ие", "иё" ])) {
								r.push(d(i, 2) + "ия");
							} else if (f(a, [ "ье", "ьё" ])) {
								let e = d(i, 2);
								"е" === l(a) && r.push(e + "ия"), r.push(e + "ья");
							} else {
								f(a, [ "дерево", "звено", "крыло" ]) ? r.push(m + "ья") : "дно" === a ? r.push("донья") : "чудо" === a ? (r.push("чудеса"), 
								r.push("чуда")) : f(a, [ "ле", "ре" ]) ? r.push(m + "я") : "судно" === a && s.isATransport() ? (r.push("суда"), 
								s.isAWatercraft() || r.push("судна")) : Array.prototype.push.apply(r, W(e => e + "а"));
							}
						} else {
							r.push(m + "и");
						}
						break;

					  case 2:
						"заря" === a ? r.push("зори") : a.endsWith("ая") ? "жш".includes(l(O)) || f(O, [ "ск", "цк" ]) ? r.push(m + "ие") : r.push(m + "ые") : D();
						break;

					  case 3:
						"мя" === o(a, 2) ? r.push(m + "ена") : Object.keys(V).includes(a) ? r.push(h(V[a]) + "и") : t.FEMININE === U ? r.push(R + "и") : "и" === l(R) ? r.push(R + "я") : r.push(R + "а");
					}
					return I(r);
				}(this, r);
			}
		}
	}, r = "бвгджзклмнпрстфхцчшщ", i = r + "й", a = "аоуэыяёюеи", u = e => a.includes(e.toLowerCase()), E = (e, t) => (e => e === e.toUpperCase())(t) ? e.toUpperCase() : e, c = e => e.split("").filter(u).length, l = e => e && e.length ? e[e.length - 1] : "", o = (e, t) => e.substring(e.length - t), h = e => e.substring(0, e.length - 1), d = (e, t) => e.substring(0, e.length - t), S = (e, t) => l(d(e, t)), f = (e, t) => t.filter(t => e.endsWith(t)).length > 0, I = e => e.filter((t, n) => e.indexOf(t) === n), A = e => e.replace("ё", "е").replace("Ё", "Е"), T = e => {
		const t = Math.max(e.toLowerCase().lastIndexOf("е"), e.toLowerCase().lastIndexOf("ё")), n = E("ё", e[t]);
		return e.substring(0, t) + n + e.substring(t + 1);
	}, p = e => 1 === e.replace(/[^её]/g, "").length;
	function m(e) {
		const t = l(e).toLowerCase();
		return ("й" === t || u(t)) && u(l(h(e))) ? d(e, 2) : u(t) ? h(e) : e;
	}
	function N(e) {
		const n = e.text(), s = e.lower(), i = e.getGender(), a = l(s);
		if ([ "ветер", "лоб", "мох", "угол", "пес", "пёс", "шов" ].includes(s) || f(s, [ "узел", "уголь", "чок", "ешок" ])) {
			const e = "ь" === a ? h(n) : n;
			return d(e, 2) + l(e);
		}
		if ([ "лев", "лёд", "лед" ].includes(s)) {
			return d(n, 2) + E("ь", l(h(n))) + l(n);
		}
		if (s.endsWith("рёк") && c(n) >= 2) {
			return d(n, 2) + "ьк";
		}
		if (s.endsWith("ёк") && u(S(n, 2))) {
			return d(n, 2) + "йк";
		}
		if (r.includes(l(s))) {
			return n;
		}
		if ("ь" === l(s)) {
			const e = [ "ясень", "бюллетень", "олень", "гордень", "пельмень", "ячмень" ];
			return s.endsWith("ень") && i === t.MASCULINE && !f(s, e) ? d(n, 3) + "н" : h(n);
		}
		return "ь" === l(h(s)) ? h(n) : "о" === l(s) && "влмнстх".includes(l(h(s))) ? h(n) : m(n);
	}
	function L(e) {
		const n = e.lower(), s = e.getGender();
		if (e.isPluraliaTantum()) {
			return;
		}
		if (e.isIndeclinable()) {
			return -1;
		}
		const r = l(n);
		switch (s) {
		  case t.FEMININE:
			return "а" == r || "я" == r ? 2 : i.includes(r) ? -1 : 3;

		  case t.MASCULINE:
			return "а" == r || "я" == r ? 2 : "путь" == n ? 0 : 1;

		  case t.NEUTER:
			return [ "дитя", "полудитя" ].includes(n) ? 0 : "мя" == o(n, 2) ? 3 : 1;

		  case t.COMMON:
			return "а" === r || "я" === r ? 2 : "и" === r ? -1 : 1;

		  default:
			throw new Error("incorrect gender");
		}
	}
	const w = e => "ц" === l(e);
	function g(e, t) {
		const n = h(e), s = h(t.lower());
		if ("а" === l(s)) {
			return n;
		}
		if ([ "зне", "жне", "гре", "спе" ].includes(o(s, 3)) || o(h(s), 3).split("").every(e => r.includes(e)) || t.isAName()) {
			return n;
		}
		if ("ле" === o(s, 2)) {
			const e = S(s, 2);
			return u(e) || "л" === e ? h(n) + "ь" : n;
		}
		return u(l(s)) && "и" !== l(s) ? u(l(h(s))) ? d(e, 2) + "й" : d(e, 2) : n;
	}
	function C(e) {
		return f(e, [ "чек", "шек" ]) && e.length >= 6 || f(e, [ "лапоток", "желток" ]) || e.endsWith("ок") && !e.endsWith("шок") && !("урок" === e) && !f(e, [ "поток", "приток", "переток", "проток", "биоток", "электроток", "восток", "водосток", "водоток", "воток", "знаток" ]) && !u(S(e, 2)) && (u(S(e, 3)) || f(d(e, 2), [ "ст", "рт" ])) && e.length >= 4;
	}
	const b = e => "ь" === l(e) || "её".includes(l(e)) && !e.endsWith("це");
	function O(t, n, s) {
		const r = n.text(), i = n.lower();
		if (i.endsWith("путь")) {
			return s === e.INSTRUMENTAL ? h(r) + "ём" : W(t, n, s);
		}
		if (!i.endsWith("дитя")) {
			throw new Error("unsupported");
		}
		switch (s) {
		  case e.NOMINATIVE:
		  case e.ACCUSATIVE:
			return r;

		  case e.GENITIVE:
		  case e.DATIVE:
		  case e.PREPOSITIONAL:
		  case e.LOCATIVE:
			return r + "ти";

		  case e.INSTRUMENTAL:
			return [ r + "тей", r + "тею" ];
		}
	}
	function x(t, n, s) {
		const r = n.text(), i = n.lower(), a = N(n), E = a.toLowerCase(), c = h(r), d = h(i), S = () => "я" === l(i), f = () => i.endsWith("ая") && !(r.length < 3 || u(l(a)));
		switch (s) {
		  case e.NOMINATIVE:
			return r;

		  case e.GENITIVE:
			return f() ? a + "ой" : n.isASurname() ? c + "ой" : S() || "гжкхчшщ".includes(l(E)) ? c + "и" : c + "ы";

		  case e.DATIVE:
			return f() ? a + "ой" : n.isASurname() ? c + "ой" : "ия" === o(i, 2) ? c + "и" : c + "е";

		  case e.ACCUSATIVE:
			return f() ? a + "ую" : S() ? c + "ю" : c + "у";

		  case e.INSTRUMENTAL:
			return f() ? a + "ой" : S() || "жцчшщ".includes(l(E)) ? "и" === l(d) ? c + "ей" : [ c + "ей", c + "ею" ] : [ c + "ой", c + "ою" ];

		  case e.PREPOSITIONAL:
			return f() ? a + "ой" : n.isASurname() ? c + "ой" : "ия" === o(i, 2) ? c + "и" : c + "е";

		  case e.LOCATIVE:
			return x(t, n, e.PREPOSITIONAL);
		}
	}
	const V = {
		"дочь": "дочерь",
		"мать": "матерь"
	};
	function W(t, n, s) {
		const r = n.text(), i = n.lower();
		if (![ e.NOMINATIVE, e.ACCUSATIVE ].includes(s) && Object.keys(V).includes(i)) {
			return W(t, n.newText(() => V[i]), s);
		}
		const a = N(n);
		if ("мя" === o(i, 2)) {
			switch (s) {
			  case e.NOMINATIVE:
				return r;

			  case e.GENITIVE:
			  case e.DATIVE:
				return a + "ени";

			  case e.ACCUSATIVE:
				return r;

			  case e.INSTRUMENTAL:
				return a + "енем";

			  case e.PREPOSITIONAL:
				return a + "ени";

			  case e.LOCATIVE:
				return W(t, n, e.PREPOSITIONAL);
			}
		} else {
			switch (s) {
			  case e.NOMINATIVE:
				return r;

			  case e.GENITIVE:
			  case e.DATIVE:
				return a + "и";

			  case e.ACCUSATIVE:
				return r;

			  case e.INSTRUMENTAL:
				return a + "ью";

			  case e.PREPOSITIONAL:
				return a + "и";

			  case e.LOCATIVE:
				return W(t, n, e.PREPOSITIONAL);
			}
		}
	}
	function M(t, n, s, i) {
		const c = i.toLowerCase(), o = c.endsWith("цы") ? h(i) : m(i), I = [ "ли", "си", "ти", "пи", "ри", "ни", "фи", "зи", "ьи", "ья", "ия" ];
		for (let e of a) {
			I.push(e + "и");
		}
		const A = () => c.endsWith("ые"), T = () => c.endsWith("ие");
		if (e.DATIVE === s) {
			return A() ? d(i, 2) + "ым" : T() ? d(i, 2) + "им" : f(c, I) ? h(i) + "ям" : o + "ам";
		}
		if (e.INSTRUMENTAL === s) {
			return A() ? d(i, 2) + "ыми" : T() ? d(i, 2) + "ими" : f(c, I) ? h(i) + "ями" : o + "ами";
		}
		if (e.PREPOSITIONAL === s) {
			return A() ? d(i, 2) + "ых" : T() ? d(i, 2) + "их" : f(c, I) ? h(i) + "ях" : o + "ах";
		}
		if (e.GENITIVE === s || e.ACCUSATIVE === s && n.isAnimate()) {
			if (A()) {
				return d(i, 2) + "ых";
			}
			if (T()) {
				return d(i, 2) + "их";
			}
		}
		const p = L(n);
		if (1 === p) {
			if ([ e.GENITIVE, e.ACCUSATIVE ].includes(s) && f(c, [ "овичи", "евичи" ])) {
				return h(i) + "ей";
			}
			if (e.GENITIVE === s || e.ACCUSATIVE === s && n.isAnimate()) {
				return f(c, [ "жи", "ши", "ля", "ли", "чи", "ри" ]) ? h(i) + "ей" : f(c, [ "звенья", "крылья" ]) ? h(i) + "ев" : f(c, [ "ья", "ия" ]) ? d(i, 2) + "ий" : f(c, [ "а", "не", "ищи" ]) && !f(c, [ "поезда", "цеха" ]) ? o : c.endsWith("цы") || c.endsWith("и") && u(S(c, 1)) ? h(i) + "ев" : h(i) + "ов";
			}
		} else if (2 === p) {
			if ([ e.GENITIVE, e.ACCUSATIVE ].includes(s) && c.endsWith("вны")) {
				return d(i, 2) + "ен";
			}
			if (e.GENITIVE === s || e.ACCUSATIVE === s && n.isAnimate()) {
				if (c.endsWith("йки")) {
					return d(i, 3) + "ек";
				}
				if (c.endsWith("ки")) {
					const e = S(c, 2);
					if ("ь" === e) {
						const e = l(h(i));
						return d(i, 3) + E("е", e) + e;
					}
					if ([ "ж", "ш", "ч" ].includes(e)) {
						return d(i, 2) + "ек";
					}
					if (r.includes(e)) {
						return d(i, 2) + "ок";
					}
				}
				if ([ "сакли", "юноши", "дяди", "распри" ].includes(c)) {
					return h(i) + "ей";
				}
				if (c.endsWith("еи")) {
					return d(i, 2) + "ей";
				}
				if ("свечи" === c) {
					return [ h(i), h(i) + "ей" ];
				}
				if ("пригоршни" === c) {
					return [ h(i) + "ей", d(i, 2) + "ен" ];
				}
				if ("тихони" === c) {
					return [ d(i, 2) + "нь", h(i) + "ей" ];
				}
				if (f(c, [ "ьи", "ии" ])) {
					return t.sd.hasStressedEndingSingular(n, s).includes(!0) ? d(i, 2) + "ей" : d(i, 2) + "ий";
				}
				if (c.endsWith("ни") && r.includes(S(c, 2))) {
					return [ "барышни", "боярышни", "деревни" ].includes(c) ? d(i, 2) + "ень" : "кухни" === c ? d(i, 2) + "онь" : d(i, 2) + "ен";
				}
				if (o.toLowerCase().endsWith("ийк")) {
					return d(o, 2) + "ек";
				}
				if (o.length === c.length - 1 && f(c, I)) {
					if ([ "ь", "й" ].includes(S(o, 1).toLowerCase())) {
						const e = l(o);
						return d(o, 2) + E("е", e) + e;
					}
					return o + "ь";
				}
				return o;
			}
		} else if ([ 3, 0 ].includes(p) && (e.GENITIVE === s || e.ACCUSATIVE === s && n.isAnimate())) {
			return o + "ей";
		}
		return i;
	}
	return Object.freeze(s);
});